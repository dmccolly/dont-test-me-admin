<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DON'T TEST ME</title>
<style>
  :root{
    --bg:#0b0f1a; --panel:rgba(20,26,38,.55); --glass:rgba(255,255,255,.07);
    --line:rgba(255,255,255,.12); --text:#e5e7eb; --muted:#9ca3af;
    --ok:#10b981; --warn:#f59e0b; --gold:#fbbf24;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif;
    color:var(--text);
    background:
      radial-gradient(900px 500px at 15% 0%,rgba(80,120,255,.12),transparent 55%),
      radial-gradient(800px 700px at 90% 20%,rgba(255,120,200,.10),transparent 60%),
      linear-gradient(180deg,#0b0f1a 0%, #0a0f18 60%, #0a0d14 100%);
    display:flex; justify-content:center; align-items:flex-start; padding:24px 12px;
  }
  .wrap{width:100%; max-width:520px}
  h1{margin:0 0 6px; font-size:32px; font-weight:800; text-align:center; letter-spacing:.02em}
  .subtitle{margin:0 0 12px; text-align:center; color:var(--muted); line-height:1.3}

  .ticker{margin:18px 0 26px; min-height:22px; text-align:center; font-weight:700; color:var(--gold)}

  .tabs{display:flex; gap:8px; justify-content:center; margin-bottom:12px; flex-wrap:wrap}
  .tab{
    padding:8px 12px; border-radius:12px; border:1px solid var(--line);
    background:var(--glass); color:#fff; cursor:pointer; font-weight:600;
  }
  .tab.active{background:rgba(16,185,129,.14); border-color:rgba(16,185,129,.35); color:var(--ok)}
  .tab.settings{opacity:.65}

  .panel{
    background:var(--panel); border:1px solid var(--line); border-radius:16px;
    padding:14px; box-shadow:0 18px 40px rgba(0,0,0,.35);
  }

  .stats{display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin-bottom:12px}
  .stat{background:rgba(255,255,255,.04); border:1px solid var(--line); border-radius:12px; text-align:center; padding:10px}
  .stat label{display:block; color:var(--muted); font-size:11px; letter-spacing:.08em; text-transform:uppercase; margin-bottom:4px}
  .stat b{font-size:20px; font-weight:800}

  .grid{display:grid; grid-template-columns:repeat(6,1fr); gap:8px; margin-bottom:12px}
  .key{
    position:relative; aspect-ratio:1/1; border-radius:14px; border:1px solid rgba(255,255,255,.14);
    display:grid; place-items:center; cursor:pointer; user-select:none;
    color:#fff; font-weight:800; font-size:20px; letter-spacing:.02em;
    background:linear-gradient(145deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    backdrop-filter:blur(16px);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.1), 0 8px 22px rgba(0,0,0,.30);
    transition:transform .12s ease, box-shadow .15s ease, border-color .15s ease, background .2s ease;
  }
  .key:hover{transform:translateY(-2px)}
  .row-0{background:linear-gradient(145deg, rgba(219,154,154,.22), rgba(150,110,110,.10)); border-color:rgba(219,154,154,.35)}
  .row-1{background:linear-gradient(145deg, rgba(154,219,168,.20), rgba(110,160,125,.10)); border-color:rgba(154,219,168,.35)}
  .row-2{background:linear-gradient(145deg, rgba(154,168,219,.20), rgba(110,125,160,.10)); border-color:rgba(154,168,219,.35)}
  .row-3{background:linear-gradient(145deg, rgba(219,195,154,.20), rgba(160,140,110,.10)); border-color:rgba(219,195,154,.35)}
  .row-4{background:linear-gradient(145deg, rgba(219,154,219,.20), rgba(150,110,150,.10)); border-color:rgba(219,154,219,.35)}
  .row-5{background:linear-gradient(145deg, rgba(154,219,219,.20), rgba(110,160,160,.10)); border-color:rgba(154,219,219,.35)}

  .key .num{transition:opacity .15s ease}
  .key.matched .num{opacity:0}
  .key.matched::before{
    content:"✓"; position:absolute; inset:0; display:grid; place-items:center;
    font-size:28px; font-weight:900; color:var(--ok); text-shadow:0 2px 10px rgba(16,185,129,.6); pointer-events:none;
  }

  .controls{display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap}
  .btn{padding:8px 12px; border-radius:12px; background:var(--glass); border:1px solid var(--line); color:#fff; font-weight:700; cursor:pointer}
  .timerChip{padding:8px 12px; border-radius:12px; background:var(--glass); border:1px solid var(--line); font-weight:700}

  .admin{display:none; margin-top:12px}
  .card{background:rgba(255,255,255,.03); border:1px solid var(--line); border-radius:12px; padding:12px; margin-bottom:12px}
  .card h4{margin:0 0 8px}
  .name-input{width:100%; padding:8px 10px; border-radius:10px; border:1px solid var(--line); background:#0e1422; color:#fff; margin-bottom:8px}
  .upload{border:2px dashed rgba(255,255,255,.18); border-radius:12px; padding:14px; text-align:center; margin-bottom:8px}
  .upload:hover{border-color:rgba(255,255,255,.35); background:rgba(255,255,255,.03)}
  .files{margin:0; padding:0; list-style:none; max-height:200px; overflow:auto}
  .files li{display:flex; justify-content:space-between; align-items:center; padding:6px 8px; border-bottom:1px dashed rgba(255,255,255,.08); gap:8px}
  .files button{background:none; border:1px solid rgba(239,68,68,.6); border-radius:8px; padding:2px 8px; color:#ef4444; font-weight:800; cursor:pointer}
  .status{font-size:12px; color:var(--muted); margin-top:4px}
  .note{color:var(--muted); text-align:center; margin-top:8px}

  @media (max-width:500px){
    .grid{gap:6px}
    .key{border-radius:12px}
  }
  @media (prefers-reduced-motion: reduce){
    .key, .key:hover{transition:none; transform:none}
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>DON'T TEST ME</h1>
    <div class="subtitle">Here's one to test your hearing AND recall. Huh? <b>I SAID. TO TEST YOUR HEARING AND RECALL!!</b></div>

    <div id="ticker" class="ticker">Welcome to the audio memory challenge!</div>

    <div class="tabs">
      <button class="tab active" id="tab-tones">Tones</button>
      <button class="tab" id="tab-c1">Custom Set 1</button>
      <button class="tab" id="tab-c2">Custom Set 2</button>
      <button class="tab settings" id="tab-settings" title="Password protected">Open Settings</button>
    </div>

    <div class="panel">
      <div class="stats">
        <div class="stat"><label>Matches</label><b id="statMatches">0/18</b></div>
        <div class="stat"><label>Attempts</label><b id="statAttempts">0</b></div>
        <div class="stat"><label>Accuracy</label><b id="statAcc">100%</b></div>
        <div class="stat"><label>Best</label><b id="statBest">—</b></div>
      </div>

      <div id="grid" class="grid"></div>

      <div class="controls">
        <button class="btn" id="btnNew">New Game</button>
        <div class="timerChip" id="timer">Time: 0:00 | Attempts: 0</div>
        <button class="btn" id="btnAudio">🔊 Audio On</button>
      </div>

      <div class="note">Upload messages & custom audio via <b>Open Settings</b>. All data persists in your browser via IndexedDB (with localStorage fallback).</div>
    </div>

    <!-- ADMIN -->
    <div id="admin" class="admin">
      <!-- Messages -->
      <div class="card">
        <h4>Funny Messages</h4>
        <div class="upload">
          <input type="file" id="msgFile" accept=".txt" />
          <div class="status">Upload a .txt file (one phrase per line, ≤150 chars)</div>
        </div>
        <ul id="msgPreview" class="files"></ul>
      </div>

      <!-- Custom Set 1 -->
      <div class="card">
        <h4>Custom Set 1</h4>
        <input class="name-input" id="name1" placeholder="Enter game name" />
        <div class="upload">
          <input type="file" id="files1" multiple accept="audio/*"/>
          <div class="status" id="status1">Empty (0/18)</div>
        </div>
        <ul id="list1" class="files"></ul>
      </div>

      <!-- Custom Set 2 -->
      <div class="card">
        <h4>Custom Set 2</h4>
        <input class="name-input" id="name2" placeholder="Enter game name" />
        <div class="upload">
          <input type="file" id="files2" multiple accept="audio/*"/>
          <div class="status" id="status2">Empty (0/18)</div>
        </div>
        <ul id="list2" class="files"></ul>
      </div>
    </div>
  </div>

<script>
/* ============================= Storage (IDB + fallback) ============================= */
const DB_NAME = 'dtm';
const DB_VERSION = 3; // schema bump
const STORES = { games:'games', messages:'messages', meta:'meta', state:'state', stats:'stats' };

const Fallback = {
  get(k){ try{ const v=localStorage.getItem(k); return v?JSON.parse(v):undefined; }catch{ return undefined; } },
  set(k,val){ try{ localStorage.setItem(k, JSON.stringify(val)); }catch{} },
  del(k){ try{ localStorage.removeItem(k); }catch{} }
};

let useFallback = false;

function openDB(){
  return new Promise((res,rej)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e=>{
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORES.games)) db.createObjectStore(STORES.games);
      if(!db.objectStoreNames.contains(STORES.messages)) db.createObjectStore(STORES.messages);
      if(!db.objectStoreNames.contains(STORES.meta)) db.createObjectStore(STORES.meta);
      if(!db.objectStoreNames.contains(STORES.state)) db.createObjectStore(STORES.state);
      if(!db.objectStoreNames.contains(STORES.stats)) db.createObjectStore(STORES.stats);
    };
    req.onsuccess = ()=>res(req.result);
    req.onerror = ()=>rej(req.error);
  });
}
async function safeOpen(){ try{ return await openDB(); } catch{ useFallback=true; return null; } }

async function idbGet(store,key){
  if(useFallback) return Fallback.get(`${store}:${key}`);
  const db = await safeOpen(); if(!db) return Fallback.get(`${store}:${key}`);
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readonly'); const r=tx.objectStore(store).get(key);
    r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);
  });
}
async function idbSet(store,key,val){
  if(useFallback){ Fallback.set(`${store}:${key}`,val); return true; }
  const db = await safeOpen(); if(!db){ Fallback.set(`${store}:${key}`,val); return true; }
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readwrite'); tx.objectStore(store).put(val,key);
    tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error);
  });
}
async function idbDel(store,key){
  if(useFallback){ Fallback.del(`${store}:${key}`); return true; }
  const db = await safeOpen(); if(!db){ Fallback.del(`${store}:${key}`); return true; }
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readwrite'); tx.objectStore(store).delete(key);
    tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error);
  });
}

/* ============================== Gold ticker ============================== */
const tickerEl=document.getElementById('ticker');
let funnyMessages=[];
async function loadMessages(){
  const arr=await idbGet(STORES.messages,'rotator');
  if(Array.isArray(arr)) funnyMessages=arr;
  startTicker();
}
function startTicker(){
  tickerEl.textContent="Welcome to the audio memory challenge!";
  setTimeout(()=>tickerEl.textContent="Match Pairs & Win!", 5000);
  setTimeout(()=>tickerEl.textContent="", 15000);
  setTimeout(()=>{
    if(!funnyMessages.length){ tickerEl.textContent="Welcome to the audio memory challenge!"; return; }
    showFunny(); setInterval(showFunny,30000);
  },25000);
}
function showFunny(){
  const msg=funnyMessages[Math.floor(Math.random()*funnyMessages.length)];
  tickerEl.textContent=msg||"";
  setTimeout(()=>tickerEl.textContent="",10000);
}

/* ============================ AudioEngine ============================ */
const AudioEngine = (()=>{
  let ctx = null;
  let unlocked = false;
  const pools = { tones: new Map(), custom: new Map() }; // key -> array of HTMLAudioElements
  const poolSize = 2;

  function ensureCtx(){
    if(!ctx){
      try{ ctx = new (window.AudioContext||window.webkitAudioContext)(); }
      catch{ ctx = null; }
    }
    return ctx;
  }

  function unlock(){
    if(unlocked) return;
    // create a tiny silent buffer to unlock iOS/Chrome policies
    try{
      const ac = ensureCtx();
      if(ac){
        const b = ac.createBuffer(1, 1, ac.sampleRate);
        const src = ac.createBufferSource();
        src.buffer = b; src.connect(ac.destination); src.start(0);
      }
    }catch{}
    unlocked = true;
  }

  function playTone(freq, dur=0.42){
    const ac = ensureCtx(); if(!ac) return;
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    osc.type='sine'; osc.frequency.value=freq;
    // quick envelope for pop-free start/stop
    const now = ac.currentTime;
    const g = gain.gain;
    g.setValueAtTime(0.0001, now);
    g.exponentialRampToValueAtTime(0.5, now+0.02);
    g.setTargetAtTime(0.0001, now+dur*0.65, 0.08);
    osc.connect(gain).connect(ac.destination);
    osc.start(now); osc.stop(now+dur);
  }

  function makePool(key, urls){
    const arr = [];
    for(let i=0;i<poolSize;i++){
      const el = new Audio();
      el.preload='auto';
      el.src = urls[0]; // src will be swapped on play
      arr.push(el);
    }
    pools.custom.set(key, arr);
  }

  function warmAll(){
    // one tick "play/pause" each element to cache decoders
    for(const [,arr] of pools.custom){
      for(const el of arr){
        try{ el.play().then(()=>{ el.pause(); el.currentTime=0; }).catch(()=>{}); }catch{}
      }
    }
  }

  function setCustomSet(key, urls){
    pools.custom.delete(key);
    if(urls && urls.length){
      makePool(key, urls);
    }
  }

  function playCustom(key, url){
    const arr = pools.custom.get(key);
    if(!arr || !arr.length){ // fallback one-shot
      const el=new Audio(url); el.play().catch(()=>{});
      return;
    }
    // find a free channel
    const ch = arr.find(a=>a.paused) || arr[0];
    if(!ch.paused){
      try{ ch.pause(); }catch{}
      ch.currentTime = 0;
    }
    ch.src = url;
    ch.play().catch(()=>{});
  }

  function onUserInteract(){
    unlock();
    warmAll();
  }

  return { ensureCtx, onUserInteract, playTone, setCustomSet, playCustom };
})();

/* =============================== UI refs =============================== */
const gridEl=document.getElementById('grid');
const statMatches=document.getElementById('statMatches');
const statAttempts=document.getElementById('statAttempts');
const statAcc=document.getElementById('statAcc');
const statBest=document.getElementById('statBest');
const timerChip=document.getElementById('timer');
const btnNew=document.getElementById('btnNew');
const btnAudio=document.getElementById('btnAudio');
const adminEl=document.getElementById('admin');
const msgFile=document.getElementById('msgFile');
const msgPreview=document.getElementById('msgPreview');
const name1=document.getElementById('name1');
const name2=document.getElementById('name2');
const files1=document.getElementById('files1');
const files2=document.getElementById('files2');
const list1=document.getElementById('list1');
const list2=document.getElementById('list2');
const status1=document.getElementById('status1');
const status2=document.getElementById('status2');

/* =============================== Game state =============================== */
let attempts=0,matches=0,totalPairs=18,audioOn=true;
let startTs=0,timerInt=null;
let firstPick=null, resolving=false;   // resolving locks a pair decision to avoid races
let mode='tones';                      // 'tones' | 'c1' | 'c2'
let cardMap=[];                        // positions -> pairId 0..17
let matchedPositions=new Array(36).fill(false);
let sources={};                        // tones/c1/c2 -> [18 urls]
let urlsToRevoke=[];

/* write throttle */
let saveQueued=false;
function scheduleSave(){ if(saveQueued) return; saveQueued=true; queueMicrotask(async ()=>{ saveQueued=false; await persistState(); }); }

/* ============================= Tone list (for stats/audio) ============================= */
const toneFreqs=[220,246,261,293,329,349,392,440,493,523,587,659,698,783,880,987,1046,1174];

/* --------------------------- UI build & behavior -------------------------- */
function buildGrid(){
  gridEl.innerHTML='';
  for(let i=0;i<36;i++){
    const b=document.createElement('button');
    b.className=`key row-${Math.floor(i/6)}`; b.innerHTML=`<span class="num">${i+1}</span>`;
    b.dataset.pos=i; b.addEventListener('click',onKey, {passive:true});
    gridEl.appendChild(b);
  }
}
function paintMatched(){
  Array.from(gridEl.children).forEach((btn,i)=>{
    btn.classList.toggle('matched', !!matchedPositions[i]);
  });
}
function setTabs(){
  document.getElementById('tab-tones').classList.toggle('active',mode==='tones');
  document.getElementById('tab-c1').classList.toggle('active',mode==='c1');
  document.getElementById('tab-c2').classList.toggle('active',mode==='c2');
}

/* ============================= Persistence API ============================= */
function stateKey(){ return `state:${mode}`; }
function statsKey(){ return `stats:${mode}`; }

async function persistState(){
  const payload = {
    cardMap, matches, attempts,
    matchedPositions,
    startTs, elapsed: startTs? (Date.now()-startTs) : 0,
    audioOn, finished: (matches===totalPairs)
  };
  await idbSet(STORES.state, stateKey(), payload);
}
async function loadState(){ return await idbGet(STORES.state, stateKey()) || null; }
async function persistStats(s){ await idbSet(STORES.stats, statsKey(), s); }
async function loadStats(){
  return await idbGet(STORES.stats, statsKey()) || { bestTimeSec:null, fewestAttempts:null, gamesPlayed:0, lastCompletedAt:null };
}
function fmtBest(stats){
  const t = stats.bestTimeSec;
  const a = stats.fewestAttempts;
  if(t==null && a==null) return '—';
  const mm = t!=null ? Math.floor(t/60) : null;
  const ss = t!=null ? (t%60).toString().padStart(2,'0') : null;
  return `${t!=null?`${mm}:${ss}`:'—'} • ${a!=null?a:'—'} att`;
}

/* =========================== Game lifecycle =========================== */
function newShuffledMap(){
  const arr=[...Array(18).keys(),...Array(18).keys()];
  for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr;
}
async function newGame(fromResume=false){
  stopAllAudio();
  firstPick=null; resolving=false;
  attempts=0; matches=0;
  matchedPositions = new Array(36).fill(false);
  statAttempts.textContent='0'; statMatches.textContent=`0/${totalPairs}`; statAcc.textContent='100%';
  Array.from(gridEl.children).forEach(btn=>btn.classList.remove('matched'));
  if(!fromResume){
    cardMap = newShuffledMap();
    startTimer(true);
  }
  scheduleSave();
}
function updateAcc(){
  const pct=attempts?Math.round((matches/attempts)*100):100;
  statAcc.textContent=`${pct}%`;
}
function updateStatsUI(stats){
  statBest.textContent = fmtBest(stats);
}

/* =========================== Click handling (race-free) =========================== */
let lastClickAt=0;
function onKey(e){
  const now = performance.now();
  if(resolving) return;                 // fully lock while deciding a pair
  if(now - lastClickAt < 80) return;    // gentle debounce for double taps
  lastClickAt = now;

  const btn=e.currentTarget;
  const pos=+btn.dataset.pos;
  if(matchedPositions[pos]) return;     // already matched
  if(firstPick && firstPick.pos===pos) return; // ignore second tap on same tile

  const pairId=cardMap[pos];

  // AUDIO first to feel responsive
  if(audioOn){
    if(mode==='tones'){ AudioEngine.playTone(toneFreqs[pairId]); }
    else{
      const url=(sources[mode]||[])[pairId]; if(url) AudioEngine.playCustom(mode, url);
    }
  }

  if(!firstPick){
    firstPick={btn,pos,pairId};
    return;
  }

  // we have a second pick -> resolve exactly once
  resolving = true;
  attempts++; statAttempts.textContent=attempts;

  if(firstPick.pairId===pairId){
    matchedPositions[firstPick.pos]=true;
    matchedPositions[pos]=true;
    firstPick.btn.classList.add('matched'); btn.classList.add('matched');
    matches++; statMatches.textContent=`${matches}/${totalPairs}`;
    if(audioOn && mode!=='tones'){ // small “ding” using tone engine
      setTimeout(()=>AudioEngine.playTone(988,0.2), 80);
    }
    firstPick=null; updateAcc(); scheduleSave();
    resolving=false;

    if(matches===totalPairs){
      stopTimer();
      handleWin();
    }
  }else{
    firstPick=null; updateAcc(); scheduleSave();
    // short delay where we ignore clicks to avoid churn
    setTimeout(()=>{ resolving=false; }, 180);
  }
}

/* ============================== Timer ============================== */
function startTimer(resetStart=false){
  clearInterval(timerInt);
  if(resetStart) startTs=Date.now();
  timerInt=setInterval(()=>{
    const s=Math.floor((Date.now()-startTs)/1000);
    const m=Math.floor(s/60), r=s%60;
    timerChip.textContent=`Time: ${m}:${r.toString().padStart(2,'0')} | Attempts: ${attempts}`;
  },1000);
}
function stopTimer(){ clearInterval(timerInt); }

/* ============================== Win ============================== */
async function handleWin(){
  const totalSec = Math.floor((Date.now()-startTs)/1000);
  const stats = await loadStats();
  if(stats.bestTimeSec==null || totalSec < stats.bestTimeSec){ stats.bestTimeSec = totalSec; }
  if(stats.fewestAttempts==null || attempts < stats.fewestAttempts){ stats.fewestAttempts = attempts; }
  stats.gamesPlayed = (stats.gamesPlayed||0)+1;
  stats.lastCompletedAt = Date.now();
  await persistStats(stats);
  updateStatsUI(stats);
  await persistState();
}

/* ============================== Audio sources ============================== */
function stopAllAudio(){ /* best-effort: WebAudio tones are short; custom pools paused before reuse */ }

/* ------------------------------- Admin wiring ----------------------------- */
document.getElementById('tab-tones').onclick=()=> switchMode('tones');
document.getElementById('tab-c1').onclick=()=> switchMode('c1');
document.getElementById('tab-c2').onclick=()=> switchMode('c2');
document.getElementById('tab-settings').onclick=async ()=>{
  const p=prompt('Enter admin password:');
  if(p==='MUSIC'){ adminEl.style.display='block'; }
  else alert('Incorrect password.');
};

btnNew.onclick=async ()=>{
  await idbDel(STORES.state, stateKey()); // fresh round; keep stats
  await newGame(false);
};
btnAudio.onclick=()=>{ audioOn=!audioOn; btnAudio.textContent=audioOn?'🔊 Audio On':'🔇 Audio Off'; scheduleSave(); };

/* Messages upload */
msgFile?.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const text=await f.text();
  const lines=text.split('\n').map(v=>v.trim()).filter(v=>v && v.length<=150).slice(0,200);
  funnyMessages=lines; await idbSet(STORES.messages,'rotator',funnyMessages); renderMessages(); alert(`Loaded ${funnyMessages.length} messages.`);
});
function renderMessages(){
  if(!msgPreview) return;
  msgPreview.innerHTML='';
  funnyMessages.slice(0,50).forEach((m)=>{ const li=document.createElement('li'); li.textContent=m; msgPreview.appendChild(li); });
}

/* Custom sets */
name1?.addEventListener('input', ()=> saveName('c1',name1.value));
name2?.addEventListener('input', ()=> saveName('c2',name2.value));
files1?.addEventListener('change', (e)=> handleFiles('c1',e.target.files));
files2?.addEventListener('change', (e)=> handleFiles('c2',e.target.files));

async function saveName(key,val){ const g=await idbGet(STORES.games,key)||{name:'',files:[]}; g.name=val||''; await idbSet(STORES.games,key,g); applyGameNames(); }
function applyGameNames(){
  const c1=(gameMeta.c1?.name||'').trim();
  const c2=(gameMeta.c2?.name||'').trim();
  document.getElementById('tab-c1').textContent=c1||'Custom Set 1';
  document.getElementById('tab-c2').textContent=c2||'Custom Set 2';
}

async function handleFiles(key,fileList){
  const files=Array.from(fileList).filter(f=>f.type.startsWith('audio/'));
  if(!files.length){ alert('Please select audio files.'); return; }
  const g=await idbGet(STORES.games,key)||{name:'',files:[]}; g.files=[];
  // Deterministic order prevents accidental “same-sounding-neighbors” confusion
  files.sort((a,b)=>a.name.localeCompare(b.name));
  for(const f of files.slice(0,18)){
    const buf=await f.arrayBuffer();
    g.files.push({name:f.name, blob:new Blob([buf],{type:f.type||'audio/mpeg'})});
  }
  await idbSet(STORES.games,key,g);
  await loadGames();
  alert(`Saved ${g.files.length} file(s) to ${key==='c1'?'Custom Set 1':'Custom Set 2'}.`);
}

/* --------------*
